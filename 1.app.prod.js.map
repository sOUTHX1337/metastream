{"version":3,"sources":["webpack:///./src/media/compose.ts","webpack:///./src/utils/http.ts","webpack:///./src/media/middleware/subreddit.ts","webpack:///./src/media/middleware/youtube.ts","webpack:///./src/media/middleware/youtube-playlist.ts","webpack:///./src/media/middleware/httpHead.ts","webpack:///./src/media/middleware/media.ts","webpack:///./src/media/middleware/html.ts","webpack:///./src/media/middleware/og.js","webpack:///./src/media/middleware/openGraph.ts","webpack:///./src/media/middleware/oembed.ts","webpack:///./src/media/middleware/autoplay.ts","webpack:///./src/media/middleware/microdata.ts","webpack:///./src/media/middleware/imgur.ts","webpack:///./src/media/index.ts"],"names":["media_compose","middleware","Array","isArray","TypeError","mware","match","resolve","ctx","index","dispatch","i","Promise","reject","Error","req","url","err","transformList","Set","prefixHeaders","headers","Object","keys","forEach","name","has","toLowerCase","fetchId","mainFetch","options","startsWith","URL","e","credentials","requestId","handler","event","data","type","window","removeEventListener","resp","payload","addEventListener","postMessage","location","origin","fetchText","async","body","URL_PATTERN","transformPost","result","id","title","subreddit","xpost","crosspost_parent_list","media","length","parent","getListing","after","urlobj","url_url","paramObj","query","limit","params","utils_url","apiUrl","protocol","hostname","pathname","json","Referer","http","getNextPosts","children","filter","post","stickied","map","[object Object]","isSubreddit","exec","href","isCommentThread","includes","state","reddit","next","reqState","redditUrl","currentIdx","idx","console","log","error","debug","posts","child","res","hasMore","item","reddit_video","v","fallback_url","duration","oembed","parseItem","youtube_URL_PATTERN","VIDEO_ID_PATTERNS","YouTubeClient","this","instance","youtube","getInstance","getVideoId","metadata","$","isoDuration","attr","metaBroadcast","metaBroadcastEndDate","utils","undefined","metaDescription","description","searchParams","getScrapedMetadata","message","referrer","oEmbed","youtube_playlist_URL_PATTERN","youtube_playlist","isYouTube","isPlaylist","Boolean","ytpl","text","trim","rawLen","split","len","parseInt","isNaN","rawIndex","get","set","toString","httpHead","response","fetchResponse","method","user-agent","referer","code","status","contentType","val","shift","getContentType","responseCode","MIME_MEDIA_TYPES","middleware_media","meta","path_browserify","buildMediaMetadata","middleware_html","host","cheerio","fieldsArray","multiple","property","fieldName","mediaMapperTwitterImage","width","height","alt","mediaMapperTwitterPlayer","stream","mediaMapper","str","parseFloat","mediaSorter","a","b","aRes","aExt","bRes","bExt","Math","max","BAD_VIDEO_TYPES","IGNORE_VIDEO_HOSTNAMES","buildHTMLMetadata","og","ogImageFallback","ogObject","key","attribs","content","push","ogImage","ogImageSecureURL","ogImageURL","ogImageWidth","twitterImageHeight","ogImageType","ogImageHeight","ogImages","zip","sort","ogVideo","ogVideoWidth","ogVideoHeight","ogVideoType","ogVideoDuration","ogVideoSecureURL","videoDuration","ogVideos","twitterImageSrc","twitterImage","twitterImageWidth","twitterImageAlt","twitterImages","twitterPlayer","twitterPlayerWidth","twitterPlayerHeight","twitterPlayerStream","twitterPlayers","allMedia","onlyGetOpenGraphInfo","ogTitle","ogDescription","supportedImageExts","each","elem","indexOf","pop","parse","image","thumbnails","0","useVideo","openGraph","WORDPRESS_OEMBED_PATH","oEmbedJson","link","test","fetchOEmbed","info","html","src","parseOembedUrl","setQueryTrue","prop","autoplay","endsWith","urlObj","search","setAutoplay","microdata","metaDuration","lib","imgur","imageSrc","__webpack_require__","d","__webpack_exports__","resolveMediaUrl","resolveMediaPlaylist","middlewares","createContext","user","finalizeMedia","desc","object","fn"],"mappings":"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","file":"1.app.prod.js","sourcesContent":["import {\n  IMediaMiddleware,\n  IMediaRequest,\n  IMediaResponse,\n  IMediaMiddlewareResolve,\n  IMediaContext\n} from './types'\n\n/**\n * Compose `middleware` returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n */\nfunction compose(middleware: IMediaMiddleware[]) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const mware of middleware) {\n    if (typeof mware.match !== 'function' || typeof mware.resolve !== 'function') {\n      throw new TypeError('Middleware must be composed of functions!')\n    }\n  }\n\n  /**\n   * @param {Object} context\n   * @return {Promise}\n   * @api public\n   */\n  return function(ctx: IMediaContext) {\n    // last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch(i: number): PromiseLike<IMediaResponse | void> {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let mware: IMediaMiddleware | undefined = middleware[i]\n      if (!mware) return Promise.resolve()\n\n      if (!mware.match(ctx.req.url, ctx)) {\n        return Promise.resolve(dispatch(i + 1))\n      }\n\n      try {\n        return Promise.resolve<any>(\n          mware.resolve(ctx, function next() {\n            return dispatch(i + 1)\n          })\n        )\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n\nexport default compose\n","import { CoreOptions, RequestResponse } from 'request'\n\ntype FetchResponse = Response & {\n  body: any\n  headers: { [key: string]: string }\n}\n\nconst transformList = new Set(['user-agent', 'referer'])\nconst prefixHeaders = (headers: any) => {\n  if (typeof headers === 'object') {\n    headers = { ...headers }\n    // Prefix reserved headers to be fixed in the extension background script\n    Object.keys(headers).forEach(name => {\n      if (transformList.has(name.toLowerCase())) {\n        headers[`X-Metastream-${name}`] = headers[name]\n      }\n    })\n  }\n  return headers\n}\n\nlet fetchId = 0\nconst mainFetch = (url: string, options: RequestInit = {}): Promise<FetchResponse> => {\n  return new Promise((resolve, reject) => {\n    if (url.startsWith('//')) {\n      url = `https:${url}`\n    }\n\n    try {\n      new URL(url)\n    } catch (e) {\n      reject(e)\n      return\n    }\n\n    options = {\n      credentials: 'omit', // ignore cookies\n      ...options,\n      headers: prefixHeaders(options.headers)\n    }\n\n    const requestId = fetchId++\n\n    const handler = (event: MessageEvent) => {\n      const { data } = event\n      if (typeof data !== 'object') return\n      if (data.type !== `metastream-fetch-response${requestId}`) return\n\n      window.removeEventListener('message', handler, false)\n\n      const { err, resp } = data.payload\n\n      if (err) {\n        reject(err)\n        return\n      }\n\n      resolve(resp)\n    }\n\n    window.addEventListener('message', handler, false)\n    window.postMessage(\n      { type: 'metastream-fetch', payload: { requestId, url, options } },\n      location.origin\n    )\n  })\n}\n\nexport const fetchText = async <T = string>(\n  url: string,\n  options?: RequestInit\n): Promise<[T, FetchResponse]> => {\n  const resp = await mainFetch(url, options)\n  return [resp.body, resp]\n}\n\nexport const fetchResponse = async (url: string, options?: RequestInit): Promise<FetchResponse> => {\n  const resp = await mainFetch(url, options)\n  return resp\n}\n","import { parse } from 'url'\nimport { encodeQueryParams } from 'utils/url'\nimport { IMediaMiddleware, MediaType, IMediaContext } from '../types'\nimport { fetchText } from 'utils/http'\nimport { MEDIA_REFERRER } from 'constants/http'\n\n// https://www.reddit.com/dev/api/\n\nconst enum ObjectType {\n  Comment = 't1',\n  Account = 't2',\n  Link = 't3',\n  Message = 't4',\n  Subreddit = 't5',\n  Award = 't6'\n}\n\nconst URL_PATTERN = /reddit\\.com\\/r\\/([^\\s/]+)\\/?/i\nconst API_LIMIT = 5\n\nconst transformPost = ({ data }: any) => {\n  let result: any = {\n    id: data.id,\n    url: data.url,\n    title: `${data.title} - /r/${data.subreddit}`\n  }\n\n  const xpost = data.crosspost_parent_list\n\n  // TODO: secure_media_embed\n  if (data.media) {\n    result.media = data.media\n  }\n\n  if (xpost && xpost.length > 0) {\n    const parent = xpost[0]\n\n    if (parent.url) {\n      result.url = parent.url\n    }\n\n    if (parent.media) {\n      result.media = parent.media\n    }\n  }\n\n  return result\n}\n\nconst getListing = async (url: string, after?: string) => {\n  const urlobj = parse(url, true)\n\n  const paramObj: { [key: string]: string | number } = {\n    ...urlobj.query,\n    limit: API_LIMIT\n  }\n\n  if (after) {\n    paramObj.after = after\n  }\n\n  const params = encodeQueryParams(paramObj)\n\n  // TODO: Keep GET params for filtering\n  // TODO: Pick up from previous playlist state\n  const apiUrl = `${urlobj.protocol}//${urlobj.hostname}${urlobj.pathname}.json?${params}`\n\n  const [json] = await fetchText<any>(apiUrl, {\n    headers: {\n      Referer: MEDIA_REFERRER\n    }\n  })\n\n  return json\n}\n\nconst getNextPosts = (json: any) => {\n  const posts = (json.data.children as any[]).filter(post => !post.data.stickied).map(transformPost)\n  return posts\n}\n\nconst parseItem = (ctx: IMediaContext, item: any): any => {\n  ctx.res.title = item.title\n\n  // Overwrite request url with subreddit post\n  const url = new URL(item.url)\n  if (url && url.href) {\n    ctx.req.url = url\n  }\n\n  const { media } = item\n  if (media) {\n    if (media.reddit_video) {\n      const v = media.reddit_video\n      ctx.res.url = v.fallback_url\n      ctx.res.duration = v.duration\n      return true\n    } else if (media.oembed) {\n      // Defer parse to oembed middleware\n      // ctx.state.oEmbedJson = media.oembed\n      return false\n    }\n  }\n\n  return false\n}\n\nconst mware: IMediaMiddleware = {\n  match(url, ctx) {\n    const isSubreddit = !!URL_PATTERN.exec(url.href)\n    const isCommentThread = url.pathname ? url.pathname.includes('/comments/') : false\n    return (isSubreddit && !isCommentThread) || !!(ctx.req.state && ctx.req.state.reddit)\n  },\n\n  async resolve(ctx, next) {\n    const reqState = ctx.req.state\n\n    let redditUrl\n    let children: any[]\n    let after\n    let currentIdx\n\n    // TODO: filter for API listings (/hot, /new, etc.)\n    // https://www.reddit.com/dev/api/#section_listings\n    if (reqState && reqState.reddit) {\n      redditUrl = reqState.reddit.href\n      children = reqState.reddit.children\n      after = reqState.reddit.after\n      currentIdx = reqState.reddit.idx\n    } else {\n      redditUrl = ctx.req.url.href\n      const json = await getListing(redditUrl)\n      console.log('Subreddit JSON', json)\n\n      if (json.error) {\n        console.debug('Error fetching subreddit posts')\n        return next()\n      }\n\n      const posts = getNextPosts(json)\n\n      if (posts.length === 0) {\n        return next()\n      }\n\n      children = posts\n      after = json.data.after\n      currentIdx = -1\n    }\n\n    let idx = currentIdx + 1\n    let child = children[idx]\n\n    if (!child) {\n      const json = await getListing(reqState!.reddit.href, reqState!.reddit.after)\n      const posts = getNextPosts(json)\n\n      if (posts.length === 0) {\n        return next()\n      }\n\n      idx = 0\n      children = posts\n      child = children[idx]\n      after = json.data.after\n\n      if (!child) {\n        return\n      }\n    }\n\n    // Save pagination info for resolving next playlist item\n    ctx.res.type = MediaType.Playlist\n    ctx.res.hasMore = true\n    ctx.res.state = {\n      ...ctx.res.state,\n      reddit: {\n        ...(reqState || {}).reddit,\n        href: redditUrl,\n        idx,\n        children,\n        after\n      }\n    }\n\n    if (!parseItem(ctx, child)) {\n      await next()\n\n      let title = child.title || ctx.res.title\n      ctx.res.title = title\n      return ctx.res\n    }\n  }\n}\n\nexport default mware\n","import { IMediaMiddleware, IMediaResponse } from '../types'\nimport { mergeMetadata, parseHtmlDescription, parseISO8601 } from '../utils'\n\nconst URL_PATTERN = /youtu\\.?be(?:.com)?/i\n\n// TODO: https://www.youtube.com/attribution_link?a=ShEHdkiTDq4&u=%2Fwatch%3Fv%3Dm-6zjXLPRHg%26feature%3Dshare\nconst VIDEO_ID_PATTERNS = [\n  /youtu\\.be\\/([^#\\&\\?]{11})/, // youtu.be/<id>\n  /\\?v=([^#\\&\\?]{11})/, // ?v=<id>\n  /\\&v=([^#\\&\\?]{11})/, // &v=<id>\n  /embed\\/([^#\\&\\?]{11})/, // embed/<id>\n  /\\/v\\/([^#\\&\\?]{11})/ // /v/<id>\n]\n\nclass YouTubeClient {\n  static getInstance(): YouTubeClient {\n    if (!this.instance) {\n      this.instance = new YouTubeClient()\n    }\n    return this.instance\n  }\n\n  private static instance: YouTubeClient\n\n  getVideoId(url: string): string | null {\n    let match\n\n    for (let i = 0; i < VIDEO_ID_PATTERNS.length; i++) {\n      match = VIDEO_ID_PATTERNS[i].exec(url)\n      if (match) {\n        break\n      }\n    }\n\n    return match ? match[1] : null\n  }\n}\n\nasync function getScrapedMetadata(url: URL, $: CheerioStatic): Promise<Partial<IMediaResponse>> {\n  const metaDuration = $('meta[itemprop=duration]')\n  const isoDuration = metaDuration.attr('content')\n\n  const metaBroadcast = $('meta[itemprop=isLiveBroadcast]')\n  const metaBroadcastEndDate = $('meta[itemprop=endDate]')\n  const isLiveBroadcast =\n    (metaBroadcast.attr('content') || '').toLowerCase() === 'true' && !metaBroadcastEndDate\n\n  let duration\n\n  if (isLiveBroadcast) {\n    duration = 0\n  } else {\n    duration = isoDuration ? parseISO8601(isoDuration) * 1000 : undefined\n  }\n\n  const metaDescription = $('#eow-description')\n  const description =\n    metaDescription.length === 1 ? parseHtmlDescription(metaDescription) : undefined\n\n  if (url.searchParams.has('t')) {\n    // TODO: parse '1h2m3s' format\n    // startTime = parseHms(query.t)\n  }\n\n  return {\n    duration,\n    description\n  }\n}\n\nconst mware: IMediaMiddleware = {\n  match(url) {\n    const { hostname = '', href = '' } = url\n    return !!URL_PATTERN.exec(hostname) && !!YouTubeClient.getInstance().getVideoId(href)\n  },\n\n  async resolve(ctx, next) {\n    let metadata\n\n    try {\n      metadata = await getScrapedMetadata(ctx.req.url, ctx.state.$!)\n    } catch (e) {\n      console.error('YouTube request failed', e.message)\n      return next()\n    }\n\n    mergeMetadata(ctx.res, metadata)\n\n    // Bypass restricted embed playback\n    ctx.res.state.referrer = true\n\n    // Disable oEmbed for playlists\n    ctx.state.oEmbed = false\n\n    return next()\n  }\n}\n\nexport default mware\n","import { Url, parse } from 'url'\nimport { buildUrl, encodeQueryParams } from 'utils/url'\nimport {\n  MediaThumbnailSize,\n  IMediaMiddleware,\n  IMediaRequest,\n  IMediaResponse,\n  MediaType,\n  IMediaContext\n} from '../types'\n\nconst URL_PATTERN = /youtu\\.?be(?:.com)?/i\n\nconst PLAYLIST_LEN_PATTERN = /\"playlist_length\":\"(\\d+)\"/i\n\ninterface IYouTubePlaylistState {\n  title: string\n  index: number\n  length: number\n}\n\nconst mware: IMediaMiddleware = {\n  match(url, ctx) {\n    const isYouTube = !!URL_PATTERN.exec(url.href)\n    const isPlaylist = url.searchParams.has('list')\n    return (isYouTube && isPlaylist) || Boolean(ctx.req.state && ctx.req.state.ytpl)\n  },\n\n  async resolve(ctx, next) {\n    const { state } = ctx.req\n    const ytpl: IYouTubePlaylistState = (state && state.ytpl) || {}\n\n    const isInitialRequest = typeof ytpl.index === 'undefined'\n\n    if (isInitialRequest) {\n      await next()\n\n      const { res } = ctx\n\n      const { body, $ } = ctx.state\n      if (!body || !$) return\n\n      const title = $('.playlist-title').text() || res.title\n      ytpl.title = (title || 'YouTube Playlist').trim()\n\n      const rawLen = $('#playlist-length')\n        .text()\n        .split(' ')[0]\n      const len = parseInt(rawLen, 10)\n      if (isNaN(len)) return\n\n      ytpl.length = len\n\n      const rawIndex = $('li.currently-playing').data('index')\n      const params = ctx.req.url.searchParams\n      const index = rawIndex || params.get('index') || '0'\n      ytpl.index = parseInt(index, 10) || 0\n\n      ctx.res.state.ytpl = ytpl\n    } else {\n      ytpl.index++\n\n      const url = ctx.req.url\n      url.pathname = '/embed/videoseries'\n      url.searchParams.set('index', `${ytpl.index}`)\n      ctx.res.url = url.toString()\n    }\n\n    let { index, length, title } = ytpl\n\n    ctx.res.title = title\n    ctx.res.state = { ...ctx.req.state, ytpl, referrer: true }\n    ctx.res.hasMore = index < length - 1\n\n    return ctx.res\n  }\n}\n\nexport default mware\n","import { MediaThumbnailSize, IMediaRequest, IMediaMiddleware, IMediaResponse } from '../types'\nimport { fetchResponse } from 'utils/http'\nimport { Url } from 'url'\nimport { basename } from 'path'\nimport { MEDIA_USER_AGENT } from 'constants/http'\n\n/** https://www.w3.org/Protocols/rfc1341/4_Content-Type.html */\nconst getContentType = (val: string | undefined) =>\n  val ? (val.split('/').shift() || '').toLowerCase() : ''\n\nconst mware: IMediaMiddleware = {\n  match({ protocol }: URL) {\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  async resolve(ctx, next) {\n    const { url } = ctx.req\n\n    // Request HEAD response to check MIME type\n    const response = await fetchResponse(url.href, {\n      method: 'HEAD',\n      headers: {\n        'user-agent': MEDIA_USER_AGENT,\n        referer: url.href // prevent hotlink blocking\n      }\n    })\n\n    const code = response.status || 200\n    // if (code >= 400) {\n    //   return;\n    // }\n\n    let contentType = response.headers['content-type']\n    contentType = Array.isArray(contentType) ? contentType[0] : contentType\n    const type = getContentType(contentType)\n\n    ctx.state.responseCode = code\n    ctx.state.contentType = contentType\n    ctx.state.type = type\n\n    return next()\n  }\n}\n\nexport default mware\n","import { Url } from 'url'\nimport { basename } from 'path'\n\nimport { IMediaMiddleware, IMediaResponse } from '../types'\n\nconst MIME_MEDIA_TYPES = new Set(['audio', 'image', 'video'])\n\nfunction buildMediaMetadata(url: URL): Partial<IMediaResponse> {\n  // TODO: get ID3 metadata from MP3s\n  return {\n    url: url.href!,\n    title: basename(url.pathname || url.href!)\n  }\n}\n\nconst mware: IMediaMiddleware = {\n  match({ protocol }) {\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  resolve({ req, res, state }, next) {\n    const { url } = req\n    const { type } = state\n\n    // Avoid GET requests to media\n    if (type && MIME_MEDIA_TYPES.has(type)) {\n      const meta = buildMediaMetadata(url)\n      res.url = meta.url || res.url\n      res.title = res.title || meta.title\n      return res\n    }\n\n    return next()\n  }\n}\n\nexport default mware\n","import { load } from 'cheerio'\nimport { IMediaMiddleware } from '../types'\nimport { fetchText } from 'utils/http'\nimport { MEDIA_USER_AGENT } from 'constants/http'\n\nconst mware: IMediaMiddleware = {\n  match({ protocol }) {\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  async resolve(ctx, next) {\n    const { url } = ctx.req\n\n    const [text, response] = await fetchText(url.href, {\n      headers: {\n        'user-agent': MEDIA_USER_AGENT,\n        host: url.host\n      }\n    })\n\n    ctx.state.body = text\n    const $ = (ctx.state.$ = load(text))\n\n    // prettier-ignore\n    ctx.res.title = $('title').text().trim() || ctx.res.title\n\n    return next()\n  }\n}\n\nexport default mware\n","import { load } from 'cheerio'\nimport { zip } from 'lodash-es'\n\nconst fieldsArray = [\n  {\n    multiple: false,\n    property: 'og:title',\n    fieldName: 'ogTitle'\n  },\n  {\n    multiple: false,\n    property: 'og:type',\n    fieldName: 'ogType'\n  },\n  {\n    multiple: true,\n    property: 'og:image',\n    fieldName: 'ogImage'\n  },\n  {\n    multiple: true,\n    property: 'og:image:url',\n    fieldName: 'ogImageURL'\n  },\n  {\n    multiple: true,\n    property: 'og:image:secure_url',\n    fieldName: 'ogImageSecureURL'\n  },\n  {\n    multiple: true,\n    property: 'og:image:width',\n    fieldName: 'ogImageWidth'\n  },\n  {\n    multiple: true,\n    property: 'og:image:height',\n    fieldName: 'ogImageHeight'\n  },\n  {\n    multiple: true,\n    property: 'og:image:type',\n    fieldName: 'ogImageType'\n  },\n  {\n    multiple: false,\n    property: 'og:url',\n    fieldName: 'ogUrl'\n  },\n  {\n    multiple: false,\n    property: 'og:audio',\n    fieldName: 'ogAudio'\n  },\n  {\n    multiple: false,\n    property: 'og:audio:url',\n    fieldName: 'ogAudioURL'\n  },\n  {\n    multiple: false,\n    property: 'og:audio:secure_url',\n    fieldName: 'ogAudioSecureURL'\n  },\n  {\n    multiple: false,\n    property: 'og:audio:type',\n    fieldName: 'ogAudioType'\n  },\n  {\n    multiple: false,\n    property: 'og:description',\n    fieldName: 'ogDescription'\n  },\n  {\n    multiple: false,\n    property: 'og:determiner',\n    fieldName: 'ogDeterminer'\n  },\n  {\n    multiple: false,\n    property: 'og:locale',\n    fieldName: 'ogLocale'\n  },\n  {\n    multiple: false,\n    property: 'og:locale:alternate',\n    fieldName: 'ogLocaleAlternate'\n  },\n  {\n    multiple: false,\n    property: 'og:site_name',\n    fieldName: 'ogSiteName'\n  },\n  {\n    multiple: true,\n    property: 'og:video',\n    fieldName: 'ogVideo'\n  },\n  {\n    multiple: true,\n    property: 'og:video:url', // An alternative to 'og:video'\n    fieldName: 'ogVideo'\n  },\n  {\n    multiple: true,\n    property: 'og:video:secure_url',\n    fieldName: 'ogVideoSecureURL'\n  },\n  {\n    multiple: true,\n    property: 'og:video:width',\n    fieldName: 'ogVideoWidth'\n  },\n  {\n    multiple: true,\n    property: 'og:video:height',\n    fieldName: 'ogVideoHeight'\n  },\n  {\n    multiple: true,\n    property: 'og:video:type',\n    fieldName: 'ogVideoType'\n  },\n  // This format is wrong, but was seen on vk.com\n  {\n    multiple: true,\n    property: 'og:video:duration',\n    fieldName: 'ogVideoDuration'\n  },\n  {\n    multiple: true,\n    property: 'video:duration',\n    fieldName: 'videoDuration'\n  },\n  {\n    multiple: false,\n    property: 'twitter:card',\n    fieldName: 'twitterCard'\n  },\n  {\n    multiple: false,\n    property: 'twitter:site',\n    fieldName: 'twitterSite'\n  },\n  {\n    multiple: false,\n    property: 'twitter:site:id',\n    fieldName: 'twitterSiteId'\n  },\n  {\n    multiple: false,\n    property: 'twitter:creator',\n    fieldName: 'twitterCreator'\n  },\n  {\n    multiple: false,\n    property: 'twitter:creator:id',\n    fieldName: 'twitterCreatorId'\n  },\n  {\n    multiple: false,\n    property: 'twitter:title',\n    fieldName: 'twitterTitle'\n  },\n  {\n    multiple: false,\n    property: 'twitter:description',\n    fieldName: 'twitterDescription'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image',\n    fieldName: 'twitterImage'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:height',\n    fieldName: 'twitterImageHeight'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:width',\n    fieldName: 'twitterImageWidth'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:src',\n    fieldName: 'twitterImageSrc'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:alt',\n    fieldName: 'twitterImageAlt'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player',\n    fieldName: 'twitterPlayer'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player:width',\n    fieldName: 'twitterPlayerWidth'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player:height',\n    fieldName: 'twitterPlayerHeight'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player:stream',\n    fieldName: 'twitterPlayerStream'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:name:iphone',\n    fieldName: 'twitterAppNameiPhone'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:id:iphone',\n    fieldName: 'twitterAppIdiPhone'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:url:iphone',\n    fieldName: 'twitterAppUrliPhone'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:name:ipad',\n    fieldName: 'twitterAppNameiPad'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:id:ipad',\n    fieldName: 'twitterAppIdiPad'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:url:ipad',\n    fieldName: 'twitterAppUrliPad'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:name:googleplay',\n    fieldName: 'twitterAppNameGooglePlay'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:id:googleplay',\n    fieldName: 'twitterAppIdGooglePlay'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:url:googleplay',\n    fieldName: 'twitterAppUrlGooglePlay'\n  }\n]\n\nvar parseNumbers = function(str) {\n  if (!isNaN(str)) {\n    str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str)\n  }\n  return str\n}\n\nvar mediaMapperTwitterImage = function(item) {\n  return {\n    url: item[0],\n    width: item[1],\n    height: item[2],\n    alt: item[3]\n  }\n}\n\nvar mediaMapperTwitterPlayer = function(item) {\n  return {\n    url: item[0],\n    width: item[1],\n    height: item[2],\n    stream: item[3]\n  }\n}\n\nvar mediaMapper = function(item) {\n  return {\n    url: item[0],\n    width: item[1],\n    height: item[2],\n    type: item[3],\n    duration: parseNumbers(item[4])\n  }\n}\n\nvar mediaSorter = function(a, b) {\n  if (!(a.url && b.url)) {\n    return 0\n  }\n\n  var aRes = a.url.match(/\\.(\\w{2,5})$/),\n    aExt = (aRes && aRes[1].toLowerCase()) || null\n  var bRes = b.url.match(/\\.(\\w{2,5})$/),\n    bExt = (bRes && bRes[1].toLowerCase()) || null\n\n  if (aExt === 'gif' && bExt !== 'gif') {\n    return -1\n  } else if (aExt !== 'gif' && bExt === 'gif') {\n    return 1\n  } else {\n    return Math.max(b.width, b.height) - Math.max(a.width, a.height)\n  }\n}\n\n/*\n * getOG - scrape that url!\n * @param string url - the url we want to scrape\n * @param function callback\n */\nexport function parse(body, options) {\n  const ogImageFallback = options.ogImageFallback === undefined ? true : options.ogImageFallback\n\n  let $ = load(body),\n    meta = $('meta'),\n    keys = Object.keys(meta)\n\n  let ogObject = {}\n\n  keys.forEach(function(key) {\n    if (!(meta[key].attribs && (meta[key].attribs.property || meta[key].attribs.name))) {\n      return\n    }\n    var property = meta[key].attribs.property || meta[key].attribs.name,\n      content = meta[key].attribs.content\n    fieldsArray.forEach(function(item) {\n      if (property === item.property) {\n        if (!item.multiple) {\n          ogObject[item.fieldName] = content\n        } else if (!ogObject[item.fieldName]) {\n          ogObject[item.fieldName] = [content]\n        } else if (Array.isArray(ogObject[item.fieldName])) {\n          ogObject[item.fieldName].push(content)\n        }\n      }\n    })\n  })\n\n  // set the ogImage or fallback to ogImageURL or ogImageSecureURL\n  ogObject.ogImage = ogObject.ogImageSecureURL\n    ? ogObject.ogImageSecureURL\n    : ogObject.ogImage\n    ? ogObject.ogImage\n    : ogObject.ogImageURL\n    ? ogObject.ogImageURL\n    : []\n  if (!ogObject.ogImage || !ogObject.ogImage.length) {\n    delete ogObject['ogImage']\n  }\n\n  /* Combine image/width/height/type\n      and sort for priority */\n  if (\n    ogObject.ogImage ||\n    ogObject.ogImageWidth ||\n    ogObject.twitterImageHeight ||\n    ogObject.ogImageType\n  ) {\n    ogObject.ogImage = ogObject.ogImage ? ogObject.ogImage : [null]\n    ogObject.ogImageWidth = ogObject.ogImageWidth ? ogObject.ogImageWidth : [null]\n    ogObject.ogImageHeight = ogObject.ogImageHeight ? ogObject.ogImageHeight : [null]\n    ogObject.ogImageType = ogObject.ogImageType ? ogObject.ogImageType : [null]\n  }\n  var ogImages = zip(\n    ogObject.ogImage,\n    ogObject.ogImageWidth,\n    ogObject.ogImageHeight,\n    ogObject.ogImageType\n  )\n    .map(mediaMapper)\n    .sort(mediaSorter)\n\n  /* Combine video/width/height/type\n      and sort for priority */\n  if (\n    ogObject.ogVideo ||\n    ogObject.ogVideoWidth ||\n    ogObject.ogVideoHeight ||\n    ogObject.ogVideoType ||\n    ogObject.ogVideoDuration\n  ) {\n    ogObject.ogVideo = ogObject.ogVideo ? ogObject.ogVideo : [null]\n    ogObject.ogVideo = ogObject.ogVideoSecureURL ? ogObject.ogVideoSecureURL : ogObject.ogVideo\n    ogObject.ogVideoWidth = ogObject.ogVideoWidth ? ogObject.ogVideoWidth : [null]\n    ogObject.ogVideoHeight = ogObject.ogVideoHeight ? ogObject.ogVideoHeight : [null]\n    ogObject.ogVideoType = ogObject.ogVideoType ? ogObject.ogVideoType : [null]\n    ogObject.ogVideoDuration = ogObject.videoDuration || ogObject.ogVideoDuration || [null]\n  }\n  var ogVideos = zip(\n    ogObject.ogVideo,\n    ogObject.ogVideoWidth,\n    ogObject.ogVideoHeight,\n    ogObject.ogVideoType,\n    ogObject.ogVideoDuration\n  )\n    .map(mediaMapper)\n    .sort(mediaSorter)\n\n  /* Combine twitter image/width/height/alt\n      and sort for priority */\n  if (\n    ogObject.twitterImageSrc ||\n    ogObject.twitterImage ||\n    ogObject.twitterImageWidth ||\n    ogObject.twitterImageHeight ||\n    ogObject.twitterImageAlt\n  ) {\n    ogObject.twitterImage = ogObject.twitterImage ? ogObject.twitterImage : ogObject.twitterImageSrc\n    ogObject.twitterImage = ogObject.twitterImage ? ogObject.twitterImage : [null]\n    ogObject.twitterImageWidth = ogObject.twitterImageWidth ? ogObject.twitterImageWidth : [null]\n    ogObject.twitterImageHeight = ogObject.twitterImageHeight ? ogObject.twitterImageHeight : [null]\n    ogObject.twitterImageAlt = ogObject.twitterImageAlt ? ogObject.twitterImageAlt : [null]\n  }\n  var twitterImages = zip(\n    ogObject.twitterImage,\n    ogObject.twitterImageWidth,\n    ogObject.twitterImageHeight,\n    ogObject.twitterImageAlt\n  )\n    .map(mediaMapperTwitterImage)\n    .sort(mediaSorter)\n\n  /* Combine twitter player/width/height/stream\n      and sort for priority */\n  if (\n    ogObject.twitterPlayer ||\n    ogObject.twitterPlayerWidth ||\n    ogObject.twitterPlayerHeight ||\n    ogObject.twitterPlayerStream\n  ) {\n    ogObject.twitterPlayer = ogObject.twitterPlayer ? ogObject.twitterPlayer : [null]\n    ogObject.twitterPlayerWidth = ogObject.twitterPlayerWidth ? ogObject.twitterPlayerWidth : [null]\n    ogObject.twitterPlayerHeight = ogObject.twitterPlayerHeight\n      ? ogObject.twitterPlayerHeight\n      : [null]\n    ogObject.twitterPlayerStream = ogObject.twitterPlayerStream\n      ? ogObject.twitterPlayerStream\n      : [null]\n  }\n  var twitterPlayers = zip(\n    ogObject.twitterPlayer,\n    ogObject.twitterPlayerWidth,\n    ogObject.twitterPlayerHeight,\n    ogObject.twitterPlayerStream\n  )\n    .map(mediaMapperTwitterPlayer)\n    .sort(mediaSorter)\n\n  // Delete temporary fields\n  fieldsArray\n    .filter(function(item) {\n      return item.multiple\n    })\n    .forEach(function(item) {\n      delete ogObject[item.fieldName]\n    })\n\n  // Select the best image\n  if (ogImages.length) {\n    if (options.allMedia) {\n      ogObject.ogImage = ogImages\n    } else {\n      ogObject.ogImage = ogImages[0]\n    }\n  }\n\n  // Select the best video\n  if (ogVideos.length) {\n    if (options.allMedia) {\n      ogObject.ogVideo = ogVideos\n    } else {\n      ogObject.ogVideo = ogVideos[0]\n    }\n  }\n\n  // Select the best twitter image\n  if (twitterImages.length) {\n    if (options.allMedia) {\n      ogObject.twitterImage = twitterImages\n    } else {\n      ogObject.twitterImage = twitterImages[0]\n    }\n  }\n\n  // Select the best player\n  if (twitterPlayers.length) {\n    if (options.allMedia) {\n      ogObject.twitterPlayer = twitterPlayers\n    } else {\n      ogObject.twitterPlayer = twitterPlayers[0]\n    }\n  }\n\n  // Check for 'only get open graph info'\n  if (!options.onlyGetOpenGraphInfo) {\n    // Get title tag if og title was not provided\n    if (!ogObject.ogTitle && $('head > title').text() && $('head > title').text().length > 0) {\n      ogObject.ogTitle = $('head > title').text()\n    }\n    // Get meta description tag if og description was not provided\n    if (\n      !ogObject.ogDescription &&\n      $('head > meta[name=\"description\"]').attr('content') &&\n      $('head > meta[name=\"description\"]').attr('content').length > 0\n    ) {\n      ogObject.ogDescription = $('head > meta[name=\"description\"]').attr('content')\n    }\n    // Get first image as og:image if there is no og:image tag.\n    if (!ogObject.ogImage && ogImageFallback) {\n      var supportedImageExts = ['jpg', 'jpeg', 'png']\n      $('img').each(function(i, elem) {\n        if (\n          $(elem).attr('src') &&\n          $(elem).attr('src').length > 0 &&\n          supportedImageExts.indexOf(\n            $(elem)\n              .attr('src')\n              .split('.')\n              .pop()\n          ) !== -1\n        ) {\n          ogObject.ogImage = {\n            url: $(elem).attr('src')\n          }\n          return false\n        }\n      })\n    }\n  }\n\n  return ogObject\n}\n","import { MediaThumbnailSize, IMediaMiddleware, IMediaResponse } from '../types'\n\nimport { parse } from './og'\nimport { mergeMetadata } from '../utils'\n\n/** Bad video types to not use. */\nconst BAD_VIDEO_TYPES = new Set(['application/x-shockwave-flash'])\n\n/** Disable using opengraph videos on specific websites. */\nconst IGNORE_VIDEO_HOSTNAMES = new Set([\n  'www.netflix.com' // ignore series trailer\n])\n\nfunction buildHTMLMetadata(url: URL, body: string): Partial<IMediaResponse> {\n  const og = parse(body, {})\n  console.log('og', og)\n  const { ogTitle: title, ogImage: image, ogDescription: description } = og\n\n  const thumbnails = image\n    ? {\n        [MediaThumbnailSize.Default]: image.url\n      }\n    : undefined\n\n  const meta: Partial<IMediaResponse> = {\n    url: url.href!,\n    title,\n    thumbnails,\n    description\n  }\n\n  let useVideo = !IGNORE_VIDEO_HOSTNAMES.has(url.hostname)\n\n  if (useVideo && og.ogVideo) {\n    const type = og.ogVideo.type\n    useVideo = type ? !BAD_VIDEO_TYPES.has(type) : true\n    if (useVideo) {\n      meta.url = og.ogVideo.url || meta.url\n    }\n    if (og.ogVideo.duration) {\n      meta.duration = og.ogVideo.duration * 1000\n    }\n  }\n\n  return meta\n}\n\nconst mware: IMediaMiddleware = {\n  match({ protocol }) {\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  async resolve(ctx, next) {\n    const { url } = ctx.req\n    const { $, body } = ctx.state\n\n    if ($ && body) {\n      const meta = buildHTMLMetadata(url, body)\n      mergeMetadata(ctx.res, meta)\n    }\n\n    return next()\n  }\n}\n\nexport default mware\n","import { load } from 'cheerio'\nimport { IMediaMiddleware } from '../types'\nimport { fetchText } from 'utils/http'\nimport { Url } from 'url'\nimport { MEDIA_USER_AGENT } from 'constants/http'\nimport { mergeMetadata } from '../utils'\n\nconst WORDPRESS_OEMBED_PATH = /\\/wp-json\\/oembed\\/.*?\\/embed/i\n\nasync function fetchOEmbed(url: string) {\n  const [json] = await fetchText(url, {\n    headers: {\n      'user-agent': MEDIA_USER_AGENT\n    }\n  })\n\n  return json as any\n}\n\nfunction parseOembedUrl(json: any) {\n  if (typeof json.html === 'string') {\n    // Decode html entities if needed\n    const html = json.html.startsWith('&lt;') ? load(json.html)('body').text() : json.html\n    const $ = load(html)\n    let src = $('iframe').attr('src')\n\n    if (src) {\n      // TODO: always use https???\n      return src.startsWith('//') ? `http:${src}` : src\n    }\n  }\n}\n\nconst mware: IMediaMiddleware = {\n  match({ protocol }) {\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  async resolve(ctx, next) {\n    if (typeof ctx.state.oEmbed === 'boolean' && !ctx.state.oEmbed) {\n      return next()\n    }\n\n    const { url } = ctx.req\n\n    let json\n\n    if (ctx.state.oEmbedJson) {\n      json = ctx.state.oEmbedJson\n    } else if (ctx.state.$) {\n      const { $ } = ctx.state\n      const link = $(`link[type='text/json+oembed'], link[type='application/json+oembed']`).attr(\n        'href'\n      )\n\n      if (\n        link &&\n        // Wordpress embeds are super generic\n        !WORDPRESS_OEMBED_PATH.test(link)\n      ) {\n        json = await fetchOEmbed(link)\n      }\n    }\n\n    if (json) {\n      console.info('oembed', json)\n      const src = parseOembedUrl(json)\n\n      const meta = {\n        url: src,\n        description: json.description\n      }\n\n      mergeMetadata(ctx.res, meta)\n    }\n\n    return next()\n  }\n}\n\nexport default mware\n","import { IMediaMiddleware } from '../types'\nimport { Url, parse, format } from 'url'\nimport { encodeQueryParams } from 'utils/url'\n\nconst setQueryTrue = (prop: string, query: any) => {\n  if (!!query[prop]) {\n    query[prop] = 'true'\n    return true\n  }\n}\n\n/** Set autoplay query param to true */\nconst setAutoplay = (url: string) => {\n  const urlObj = parse(url, true)\n  const { query } = urlObj\n\n  if (!(setQueryTrue('autoplay', query) || setQueryTrue('auto_play', query))) {\n    ;['autoplay', 'auto_play'].forEach(prop => {\n      query[prop] = 'true'\n    })\n  }\n\n  urlObj.search = encodeQueryParams(query)\n\n  return format(urlObj)\n}\n\nconst mware: IMediaMiddleware = {\n  match({ protocol, host }) {\n    // BUG: server returns Access Denied\n    if (host && host.indexOf('redd.it') > -1) {\n      return false\n    }\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  async resolve(ctx, next) {\n    const { url } = ctx.res\n\n    // TODO: use mime-type instead of extension\n    // need a way to compose httpHead/media mware after microdata changes url\n    const isMedia = url ? url.endsWith('mp4') : false\n\n    if (!isMedia) {\n      ctx.res.url = setAutoplay(url)\n    }\n\n    return next()\n  }\n}\n\nexport default mware\n","import { load } from 'cheerio'\n\nimport { IMediaMiddleware } from '../types'\nimport { parse, toSeconds } from 'iso8601-duration'\n\nconst mware: IMediaMiddleware = {\n  match({ protocol }) {\n    return protocol === 'http:' || protocol === 'https:'\n  },\n\n  async resolve(ctx, next) {\n    const { url } = ctx.req\n    const { $ } = ctx.state\n\n    // TODO: clean this up and make it more robust\n    if ($) {\n      const noscript = $(`noscript`)\n\n      noscript.each(function(idx: number, elem: any) {\n        const node = ctx.state.$!(elem)\n        const text = node.text()\n\n        if (text.indexOf('schema.org') === -1) {\n          return\n        }\n\n        const $ = load(text)\n\n        const metaDuration = $(`meta[itemprop='duration']`).attr('content')\n        if (metaDuration) {\n          const duration = toSeconds(parse(metaDuration)) * 1000\n\n          if (duration && !isNaN(duration)) {\n            ctx.res.duration = duration\n          }\n        }\n      })\n    }\n\n    return next()\n  }\n}\n\nexport default mware\n","import { IMediaMiddleware } from '../types'\n\nconst mware: IMediaMiddleware = {\n  match(url) {\n    const { hostname = '' } = url\n    return hostname.endsWith('imgur.com')\n  },\n\n  async resolve(ctx, next) {\n    const { $ } = ctx.state\n\n    if ($) {\n      const title = $('title')\n        .text()\n        .trim()\n      const imageSrc = $('link[rel=image_src]').attr('href')\n      const isAlbum = title.endsWith('Album on Imgur')\n\n      if (!isAlbum && imageSrc) {\n        await next()\n        ctx.res.url = imageSrc\n        return ctx.res\n      }\n    }\n\n    return next()\n  }\n}\n\nexport default mware\n","import { cleanObject } from 'utils/object'\nimport compose from './compose'\n\nimport { IMediaMiddleware, IMediaRequest, IMediaResponse, IMediaContext, MediaType } from './types'\n\nimport subredditMware from './middleware/subreddit'\nimport youTubeMware from './middleware/youtube'\nimport youTubePlaylistMware from './middleware/youtube-playlist'\nimport httpHeadMware from './middleware/httpHead'\nimport mediaMware from './middleware/media'\nimport htmlMware from './middleware/html'\nimport openGraphMware from './middleware/openGraph'\nimport oEmbedMware from './middleware/oembed'\nimport autoplayMware from './middleware/autoplay'\nimport microdataMware from './middleware/microdata'\nimport imgurMware from './middleware/imgur'\n\nimport { IMediaItem } from 'lobby/reducers/mediaPlayer'\n\n// prettier-ignore\nconst middlewares: IMediaMiddleware[] = [\n  subredditMware,\n  youTubePlaylistMware,\n\n  httpHeadMware,\n  mediaMware,\n  htmlMware,\n\n  youTubeMware,\n  imgurMware,\n\n  openGraphMware,\n  oEmbedMware,\n  microdataMware,\n  autoplayMware\n];\n\ntype MediaUrl = URL\n\nconst createContext = (url: MediaUrl) => {\n  const req: IMediaRequest = {\n    type: MediaType.Item,\n    url,\n\n    // TODO: add user info for logging middleware\n    user: null\n  }\n\n  const res: IMediaResponse = {\n    type: MediaType.Item,\n    url: url.href,\n    state: {}\n  }\n\n  const ctx: IMediaContext = {\n    req,\n    res,\n    state: {}\n  }\n\n  return ctx\n}\n\nconst finalizeMedia = (media: IMediaResponse) => {\n  if (media.description) {\n    const desc = media.description.trim()\n    media.description = desc || undefined\n  }\n  return cleanObject(media)\n}\n\nexport const resolveMediaUrl = async (url: string): Promise<Readonly<IMediaResponse> | null> => {\n  const urlObj: MediaUrl = new URL(url)\n  if (!urlObj.href) {\n    return null\n  }\n\n  const ctx = createContext(urlObj)\n\n  const fn = compose(middlewares)\n  const result = (await fn(ctx)) || ctx.res\n  console.debug('Resolved media', ctx)\n  return finalizeMedia(result)\n}\n\nexport const resolveMediaPlaylist = async (\n  media: IMediaItem\n): Promise<Readonly<IMediaResponse> | null> => {\n  const urlObj: MediaUrl = new URL(media.url)\n  if (!urlObj.href) {\n    return null\n  }\n\n  const ctx = createContext(urlObj)\n\n  // Transfer old state to new request\n  ctx.req = {\n    ...ctx.req,\n    type: media.type,\n    state: media.state\n  }\n\n  console.log('resolving playlist', ctx)\n\n  const fn = compose(middlewares)\n  const result = (await fn(ctx)) || ctx.res\n  return finalizeMedia(result)\n}\n"],"sourceRoot":""}